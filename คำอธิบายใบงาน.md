# 📚 คำอธิบายใบงาน: การ Deploy แอปพลิเคชันด้วย GitHub Actions และ Self-Hosted Runner

## 🎯 ภาพรวมของใบงาน

ใบงานนี้สอนให้คุณเข้าใจและปฏิบัติการเกี่ยวกับ **CI/CD (Continuous Integration/Continuous Deployment)** โดยใช้ **GitHub Actions** ร่วมกับ **Self-Hosted Runner** เพื่อ deploy แอปพลิเคชัน Node.js ไปยังเครื่องของคุณเอง

---

## 📖 ส่วนที่ 1: ความเข้าใจพื้นฐาน

### 🤔 CI/CD คืออะไร?

**CI/CD** ย่อมาจาก:
- **CI (Continuous Integration)**: การรวมโค้ดจากหลายคนเข้าด้วยกันและทดสอบอัตโนมัติ
- **CD (Continuous Deployment)**: การ deploy แอปพลิเคชันอัตโนมัติเมื่อโค้ดผ่านการทดสอบ

**ตัวอย่างการทำงาน:**
```
Developer → Push Code → GitHub → CI/CD Pipeline → Deploy อัตโนมัติ
```

### 🤖 GitHub Actions Runner คืออะไร?

**Runner** คือเครื่องที่รันงาน (jobs) จาก GitHub Actions workflows

**มี 2 ประเภท:**

1. **GitHub-Hosted Runner (Cloud Runner)**
   - เป็นเครื่องของ GitHub ที่ให้ใช้ฟรี (มีข้อจำกัด)
   - รันบน cloud ของ GitHub
   - ไม่ต้องติดตั้งเอง

2. **Self-Hosted Runner** ⭐ (สิ่งที่เราจะเรียนในใบงานนี้)
   - เป็นเครื่องที่เราติดตั้งและดูแลเอง
   - รันบนเครื่องของเรา (Mac, Windows, Linux)
   - ควบคุมได้เต็มที่

---

## 🔄 ส่วนที่ 2: Pull-based Model (หัวใจสำคัญ!)

### ❓ Pull-based คืออะไร?

**Pull-based Model** คือรูปแบบที่ **Runner เป็นฝ่ายดึงงาน** จาก GitHub แทนที่จะรอให้ GitHub ส่งงานมาให้

### 🔄 เปรียบเทียบ 2 แบบ:

#### แบบ Push-based (แบบเก่า - ไม่ใช้ใน GitHub Actions)
```
GitHub → ส่งงานมา → Runner (ต้องเปิด Port รอรับ)
```
- ❌ ต้องเปิด Port ให้โลกภายนอกเข้าถึง
- ❌ ต้องมี Static IP
- ❌ ปลอดภัยน้อยกว่า

#### แบบ Pull-based (ที่ GitHub Actions ใช้) ⭐
```
Runner → ถาม GitHub → "มีงานไหม?" → GitHub ตอบ → Runner รับงาน
```
- ✅ ไม่ต้องเปิด Port
- ✅ ไม่ต้องมี Static IP
- ✅ ปลอดภัยกว่า (Firewall บล็อก inbound ได้)

### 🔍 การทำงานของ Polling

**Polling** คือการที่ Runner ถาม GitHub เป็นระยะๆ ว่า "มีงานไหม?"

**ตัวอย่างการทำงาน:**
```javascript
// Runner ทำแบบนี้ทุก 1-2 วินาที
while (runner ยังทำงานอยู่) {
  1. ส่ง request ไปที่ GitHub API
  2. ถามว่า "มีงานให้ฉันทำไหม?"
  3. ถ้ามี → รับงานมาและทำ
  4. ถ้าไม่มี → รอสักครู่แล้วถามใหม่
}
```

**Long-Polling Technique:**
- Runner เปิด connection และรอสูงสุด 60 วินาที
- ถ้ามีงานใหม่ GitHub จะตอบทันที
- ถ้าไม่มีงานใน 60 วินาที GitHub จะตอบ "ไม่มีงาน" แล้ว Runner ถามใหม่
- ทำให้ได้รับงานเร็วโดยไม่ต้องส่ง request บ่อยเกินไป

---

## 🏗️ ส่วนที่ 3: สถาปัตยกรรมระบบ

### 📊 แผนภาพการทำงาน:

```
┌─────────────────────────────────────────┐
│      GitHub Cloud Platform             │
│  ┌──────────┐  ┌──────────┐           │
│  │Repository│→ │ Workflow │→ Job Queue │
│  └──────────┘  └──────────┘           │
└───────────────────▲────────────────────┘
                    │
                    │ HTTPS Polling
                    │ (Outbound)
                    │
        ┌───────────┴───────────┐
        │   Firewall            │
        │ (บล็อก Inbound)       │
        └───────────┬───────────┘
                    │
                    │
        ┌───────────▼───────────┐
        │  Self-Hosted Runner   │
        │  (บนเครื่องของคุณ)    │
        └───────────┬───────────┘
                    │
                    │ Deploy
                    │
        ┌───────────▼───────────┐
        │   Docker Compose      │
        │  ┌──────┐  ┌──────┐  │
        │  │ App  │  │Nginx │  │
        │  └──────┘  └──────┘  │
        └───────────────────────┘
```

### 🔄 ขั้นตอนการทำงาน:

1. **Developer Push Code**
   - นักพัฒนา push code ขึ้น GitHub

2. **GitHub ตรวจจับและสร้าง Job**
   - GitHub ตรวจจับ push event
   - สร้าง Workflow Run
   - สร้าง Job และเก็บไว้ใน Job Queue

3. **Runner Polling**
   - Runner ถาม GitHub เป็นระยะๆ
   - GitHub ตอบว่ามีงาน
   - Runner รับงานมา

4. **Runner ทำงาน**
   - Clone repository
   - Build Docker image
   - Deploy ด้วย Docker Compose
   - รายงานผลกลับ GitHub

---

## 🛠️ ส่วนที่ 4: ขั้นตอนการปฏิบัติ (Step-by-Step)

### 📝 ขั้นตอนที่ 1: เตรียมโครงสร้างโปรเจค

#### 1.1 สร้าง Repository บน GitHub
- ไปที่ https://github.com
- สร้าง repository ใหม่ชื่อ `nodejs-cicd-selfhosted`
- ⚠️ **สำคัญ:** ต้องเป็น **Private Repository** เท่านั้น!
  - เพราะ Self-Hosted Runner จะรันโค้ดบนเครื่องของคุณ
  - ถ้าเป็น Public อาจถูกโจมตีได้

#### 1.2 Clone Repository
```bash
git clone https://github.com/YOUR_USERNAME/nodejs-cicd-selfhosted.git
cd nodejs-cicd-selfhosted
```

#### 1.3 สร้างโครงสร้างไฟล์
```bash
mkdir -p .github/workflows
touch server.js package.json Dockerfile docker-compose.yml nginx.conf .gitignore .dockerignore
```

---

### 📦 ขั้นตอนที่ 2: สร้าง Node.js Application

#### 2.1 package.json
- ไฟล์ที่บอกข้อมูลโปรเจคและ dependencies
- ต้องมี `package-lock.json` ด้วย (สำคัญมาก!)

#### 2.2 server.js
- แอปพลิเคชัน Node.js ที่ใช้ Express
- มี endpoints:
  - `GET /` - หน้าแรก
  - `GET /health` - ตรวจสอบสุขภาพ
  - `GET /api/info` - ข้อมูลแอปพลิเคชัน

---

### 🐳 ขั้นตอนที่ 3: สร้าง Docker Configuration

#### 3.1 Dockerfile
- ไฟล์ที่บอกวิธี build Docker image
- ใช้ **Multi-stage build** เพื่อลดขนาด image
- ⚠️ **สำคัญ:** ใช้ `npm ci` แทน `npm install`
  - `npm ci` เร็วกว่าและให้ผลเหมือนกันทุกครั้ง
  - ต้องมี `package-lock.json`

#### 3.2 docker-compose.yml
- ไฟล์ที่บอกวิธีรัน containers หลายตัวพร้อมกัน
- มี 2 services:
  1. **app** - แอปพลิเคชัน Node.js
  2. **nginx** - Reverse proxy

#### 3.3 nginx.conf
- ไฟล์ config ของ Nginx
- ทำหน้าที่เป็น Reverse Proxy
- รับ request ที่ port 80 แล้วส่งต่อไปยัง app ที่ port 3000

---

### ⚙️ ขั้นตอนที่ 4: สร้าง GitHub Actions Workflow

#### 4.1 ไฟล์ `.github/workflows/deploy.yml`
- ไฟล์ที่บอก GitHub Actions ว่าต้องทำอะไรเมื่อมี push
- ใช้ `runs-on: self-hosted` เพื่อบอกให้ใช้ Self-Hosted Runner

#### 4.2 ขั้นตอนใน Workflow:
1. **Checkout Code** - ดึงโค้ดจาก repository
2. **Set Version** - ตั้งค่าเวอร์ชัน
3. **Display Environment** - แสดงข้อมูล environment
4. **Verify package-lock.json** - ตรวจสอบว่ามีไฟล์นี้
5. **Stop Existing Services** - หยุด services เดิม
6. **Build Docker Image** - สร้าง Docker image
7. **Start Services** - เริ่ม services ด้วย Docker Compose
8. **Check Service Health** - ตรวจสอบว่า services ทำงาน
9. **Test Application** - ทดสอบ endpoints
10. **Display Status** - แสดงสถานะ
11. **Display Logs** - แสดง logs
12. **Deployment Summary** - สรุปผลการ deploy

---

### 🚀 ขั้นตอนที่ 5: ติดตั้ง Self-Hosted Runner

#### 5.1 ไปที่ GitHub Repository Settings
- Settings → Actions → Runners → New self-hosted runner

#### 5.2 Download Runner
```bash
# สำหรับ macOS
mkdir actions-runner && cd actions-runner
curl -o actions-runner-osx-x64-2.311.0.tar.gz -L \
  https://github.com/actions/runner/releases/download/v2.311.0/actions-runner-osx-x64-2.311.0.tar.gz
tar xzf ./actions-runner-osx-x64-2.311.0.tar.gz
```

#### 5.3 Configure Runner
```bash
./config.sh --url https://github.com/YOUR_USERNAME/nodejs-cicd-selfhosted --token YOUR_TOKEN
```
- ใช้ token จาก GitHub Settings

#### 5.4 เริ่ม Runner
```bash
# แบบทดสอบ
./run.sh

# แบบ service (รันอัตโนมัติ)
sudo ./svc.sh install
sudo ./svc.sh start
```

---

### 🧪 ขั้นตอนที่ 6: ทดสอบ CI/CD Pipeline

#### 6.1 Push Code
```bash
git add .
git commit -m "Test CI/CD"
git push origin main
```

#### 6.2 ดูผลลัพธ์
- ไปที่ GitHub → Actions tab
- ดู workflow run
- Runner จะรับงานและ deploy อัตโนมัติ

#### 6.3 ทดสอบ Application
```bash
curl http://localhost:8080
curl http://localhost:8080/health
```

---

## 🔑 จุดสำคัญที่ต้องจำ

### ✅ สิ่งที่ต้องทำ:

1. **ต้องมี package-lock.json**
   - ใช้ `npm ci` แทน `npm install`
   - ต้อง commit ลง git

2. **ใช้ Multi-stage Docker Build**
   - ลดขนาด image
   - ปลอดภัยกว่า

3. **ใช้ Non-root User**
   - ใช้ user `node` ใน container
   - เพิ่มความปลอดภัย

4. **มี Health Checks**
   - ตรวจสอบก่อน deploy

5. **ใช้ Private Repository**
   - ปลอดภัยกว่า Public

### ❌ สิ่งที่ต้องหลีกเลี่ยง:

1. ❌ ไม่ใช้ Self-Hosted Runner กับ Public Repository
2. ❌ ไม่ ignore `package-lock.json`
3. ❌ ไม่ใช้ `npm install` ใน Dockerfile
4. ❌ ไม่รัน runner ด้วย root user
5. ❌ ไม่ hard-code secrets ในโค้ด

---

## 🎓 คำถามสำคัญ

### 1. Pull-based Model คืออะไร?

**คำตอบ:** 
- Runner เป็นฝ่ายดึงงานจาก GitHub
- Runner ทำการ Polling (ถามเป็นระยะๆ)
- ไม่ต้องเปิด Port
- ไม่ต้องมี Static IP
- ปลอดภัยกว่า

### 2. ทำไม Pull-based ปลอดภัยกว่า?

**คำตอบ:**
- ไม่ต้องเปิด Port ให้โลกภายนอก
- Firewall บล็อก inbound ได้
- Runner เป็นฝ่ายเชื่อมต่อออกไปหา GitHub
- ไม่มีจุดเข้าจากภายนอก

### 3. ทำไมต้องใช้ npm ci?

**คำตอบ:**
- เร็วกว่า `npm install`
- ให้ผลเหมือนกันทุกครั้ง
- ต้องมี `package-lock.json`
- ลบ `node_modules` ก่อนติดตั้งใหม่เสมอ

### 4. ทำไมห้ามใช้กับ Public Repository?

**คำตอบ:**
- ใครก็ได้สามารถสร้าง workflow ที่รันบน Runner ของคุณ
- อาจถูกโจมตีหรือขโมยข้อมูล
- ใช้ได้เฉพาะ Private Repository

### 5. Nginx Reverse Proxy คืออะไร?

**คำตอบ:**
- Nginx รับ request จาก client
- ส่งต่อไปยัง backend application
- แยก frontend/backend
- จัดการ SSL/TLS
- Load balancing
- เพิ่มความปลอดภัย

---

## 📚 สรุป

ใบงานนี้สอนให้คุณ:

1. ✅ เข้าใจ Pull-based Model ของ Self-Hosted Runner
2. ✅ ติดตั้งและตั้งค่า Self-Hosted Runner
3. ✅ สร้าง CI/CD Pipeline ด้วย GitHub Actions
4. ✅ Deploy แอปพลิเคชันด้วย Docker Compose
5. ✅ ตั้งค่า Nginx Reverse Proxy

**ประโยชน์ที่ได้:**
- Deploy อัตโนมัติเมื่อ push code
- ควบคุม infrastructure เอง
- ปลอดภัยกว่า (ไม่ต้องเปิด Port)
- เรียนรู้ CI/CD แบบมืออาชีพ

---

## 🔗 เอกสารอ้างอิง

- [GitHub Actions Self-Hosted Runners](https://docs.github.com/en/actions/hosting-your-own-runners)
- [npm ci Documentation](https://docs.npmjs.com/cli/v10/commands/npm-ci)
- [Docker Multi-stage Builds](https://docs.docker.com/build/building/multi-stage/)
- [Nginx Reverse Proxy Guide](https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/)

